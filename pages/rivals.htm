<!DOCTYPE html>
<html>

<head>
    <title>Marvel Rivals Stats</title>
    <meta charset="UTF-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.js"
        integrity="sha512-8BHxHDLsOHx+flIrQ0DrZcea7MkHqRU5GbTHmbdzMRnAaoCIkZ97PqZcXJkKZckMMhqfoeaJE+DNUVuyoQsO3Q=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>

<body>
    <div class="grandinfo">
        <div class="info hide">
            <div class="profile-container">
                <img class="avatar" id="avatar" src="">
                <div class="profile-text">
                    <div class="username-clan">
                        <div class="username" id="username"></div>
                        <div class="guild-name" id="guild-name"></div>
                    </div>
                    <div class="rank" id="rank"></div>
                </div>
            </div>
            <div class="divider"></div>
            <div class="hero-stats" id="hero-stats">
                <div class="hero-content" id="hero-content">
                    <div class="hero-info">
                        <div class="hero-icon-container">
                            <div class="hero-icon-bg" id="hero-icon-bg"></div>
                            <img class="hero-icon" id="hero-icon" src="">
                        </div>
                        <div class="hero-name" id="hero-name"></div>
                        <div class="hero-role" id="hero-role"></div>
                        <div class="hero-stats-grid" id="hero-stats-grid"></div>
                    </div>
                </div>
            </div>
            <div style="margin-bottom: 10px; transform: translateY(-10px);">
                <p style="opacity: 0.4">Holy Ghost Prep E-Sports</p>
            </div>
        </div>
    </div>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            background: transparent;
            color: white;
            border: 0 transparent;
            padding: 0;
            margin: 0;
            text-align: center;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", sans-serif;
            font-weight: 400;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            letter-spacing: -0.02em;
        }

        @keyframes mesh-gradient {
            0% {
                background-position: 0% 50%;
            }

            25% {
                background-position: 50% 100%;
            }

            50% {
                background-position: 100% 50%;
            }

            75% {
                background-position: 50% 0%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        @keyframes float-up {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fade-scale-in {
            from {
                opacity: 0;
                transform: scale(0.98);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes cross-fade {
            0% {
                opacity: 1;
                transform: translateY(0);
            }

            45% {
                opacity: 0;
                transform: translateY(-10px);
            }

            55% {
                opacity: 0;
                transform: translateY(10px);
            }

            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slide-out-anim {
            from {
                opacity: 1;
                transform: translateX(0);
            }

            to {
                opacity: 0;
                transform: translateX(-50px);
            }
        }

        @keyframes slide-in-anim {
            from {
                opacity: 0;
                transform: translateX(50px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes stats-out-retreat {
            from {
                opacity: 1;
                transform: scale(1);
            }

            to {
                opacity: 0;
                transform: scale(0.5);
            }
        }

        @keyframes hero-icon-out {
            from {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }

            to {
                opacity: 0;
                transform: scale(0.8) rotate(-10deg);
            }
        }

        @keyframes hero-icon-in {
            from {
                opacity: 0;
                transform: scale(0.8) rotate(10deg);
            }

            to {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
        }

        .grandinfo {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .info {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            gap: 20px;
            width: 30vw;
            height: 90vh;

            padding: 32px;
            position: relative;
            overflow: visible;
            transform-origin: center center;

            background-color: rgb(0, 0, 0);
            background-image:
                radial-gradient(at 40% 20%, hsla(302, 100%, 74%, 1) 0px, transparent 50%),
                radial-gradient(at 80% 0%, hsla(271, 100%, 56%, 1) 0px, transparent 50%),
                radial-gradient(at 0% 50%, hsla(240, 100%, 72%, 1) 0px, transparent 50%),
                radial-gradient(at 80% 50%, hsla(340, 100%, 76%, 1) 0px, transparent 50%),
                radial-gradient(at 0% 100%, hsla(302, 100%, 77%, 1) 0px, transparent 50%),
                radial-gradient(at 80% 100%, hsla(240, 100%, 81%, 1) 0px, transparent 50%),
                radial-gradient(at 0% 0%, hsla(343, 100%, 76%, 1) 0px, transparent 50%);
            background-size: 200% 200%;
            box-shadow: none !important;

            border: 4px solid rgba(255, 255, 255, 0.4);

            opacity: 0;
            transform: none;
            transition: all 0.3s ease-out;
        }

        .info.show {
            opacity: 1;
            transform: none;
        }

        .info.hide {
            opacity: 0;
            transform: none;
            pointer-events: none;
        }

        .info.animation-done {
            animation: mesh-gradient 16s ease-in-out infinite;
            opacity: 1;
            transform: none;
            transition: none;
        }

        .profile-container {
            position: relative;
            flex-shrink: 0;
            z-index: 2;
            display: flex;
            flex-direction: row;
            gap: 20px;
            width: 100%;
        }

        .username-clan {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 12px;
        }

        .guild-name {
            font-size: 1.2rem;
            font-weight: bolder;
            animation: float-up 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.3s both;
            vertical-align: middle;
            font-style: italic;
            background-color: white;
            color: #000;
            padding: 4px 8px;
        }

        .avatar {
            height: 80px;
            width: 80px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            object-fit: cover;
            animation: fade-scale-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            transition: transform 0.3s ease;
            z-index: 2;
            position: relative;
        }

        .avatar:hover {
            transform: scale(1.02);
        }

        .profile-text {
            text-align: left;
            z-index: 2;
        }

        .username {
            font-weight: 700;
            font-size: 2rem;
            background: linear-gradient(135deg, #ffffff 0%, rgba(255, 255, 255, 0.8) 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: float-up 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.1s both;
            letter-spacing: -0.03em;
            margin-bottom: 8px;
        }

        .rank {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.8);
            animation: float-up 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.2s both;
        }

        .guild-info {
            text-align: center;
            z-index: 2;
        }

        .divider {
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            margin: 10px 0;
            z-index: 2;
        }

        .hero-stats {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2;
        }

        .hero-content {
            display: flex;
            align-items: center;
            gap: 20px;
            opacity: 1;
            transition: opacity 0.5s ease-in-out;
        }

        .hero-content.slide-out {
            animation: slide-out-anim 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        .hero-content.slide-in {
            animation: slide-in-anim 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        .hero-icon-container {
            position: relative;
            display: inline-block;
        }

        .hero-icon {
            height: 200px;
            aspect-ratio: 1/1;
            object-fit: cover;
            animation: fade-scale-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            transition: transform 0.3s ease;
            position: relative;
        }

        .hero-info {
            text-align: left;
            flex: 1;
            min-width: 0;
        }

        .hero-name {
            font-size: 2rem;
            font-weight: 600;
            color: white;
            margin-bottom: 4px;
            animation: float-up 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.1s both;
        }

        .hero-role {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 8px;
            animation: float-up 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.2s both;
        }

        .hero-stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.3);
            padding: 0.5vw 0.8vw;
            text-align: center;
            min-height: 4vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .stat-value {
            font-size: 1.4vw;
            font-weight: 600;
            color: white;
        }

        .stat-label {
            font-size: 0.75vw;
            color: rgba(255, 255, 255, 0.9);
            margin-top: 0.2vh;
        }

        .stat-item.updated .stat-value {
            animation: flash 0.5s ease-out;
        }

        @keyframes flash {
            0% {
                color: #ffffff;
                transform: scale(1.1);
            }

            50% {
                color: #ffff00;
                transform: scale(1.2);
            }

            100% {
                color: #ffffff;
                transform: scale(1);
            }
        }
    </style>
    <script>
        let socket = io();
        let currentHeroIndex = 0;
        let heroStats = [];
        let switchInterval;
        let current_palette = null;
        let heroPreviousStats = {};
        let isTransitioning = false;

        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            const k = n => (n + h / 30) % 12;
            const a = s * Math.min(l, 1 - l);
            const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
            return [
                Math.round(255 * f(0)),
                Math.round(255 * f(8)),
                Math.round(255 * f(4))
            ];
        }

        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [
                Math.round(h * 360),
                Math.round(s * 100),
                Math.round(l * 100)
            ];
        }

        function rgbToHex(r, g, b) {
            return "#" + [r, g, b].map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            }).join('');
        }

        function generateComplementaryColors(baseColor) {
            const [h, s, l] = rgbToHsl(baseColor.r, baseColor.g, baseColor.b);
            const generated = [];

            generated.push({
                r: baseColor.r,
                g: baseColor.g,
                b: baseColor.b,
                h, s, l,
                rgb: [baseColor.r, baseColor.g, baseColor.b]
            });

            const [r1, g1, b1] = hslToRgb((h + 60) % 360, Math.min(s + 10, 100), Math.min(l + 10, 90));
            generated.push({ r: r1, g: g1, b: b1, h: (h + 60) % 360, s: Math.min(s + 10, 100), l: Math.min(l + 10, 90), rgb: [r1, g1, b1] });

            const [r2, g2, b2] = hslToRgb((h - 60 + 360) % 360, Math.min(s + 10, 100), Math.min(l + 10, 90));
            generated.push({ r: r2, g: g2, b: b2, h: (h - 60 + 360) % 360, s: Math.min(s + 10, 100), l: Math.min(l + 10, 90), rgb: [r2, g2, b2] });

            return generated;
        }

        function extractPaletteFromImage(imgElement) {
            return new Promise((resolve) => {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 100;
                    canvas.height = 100;

                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    img.onload = function () {
                        ctx.drawImage(img, 0, 0, 100, 100);
                        const imageData = ctx.getImageData(0, 0, 100, 100);
                        const data = imageData.data;

                        const colorBuckets = {};
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            const a = data[i + 3];

                            if (a < 128) continue;

                            const key = `${Math.round(r / 8)},${Math.round(g / 8)},${Math.round(b / 8)}`;
                            colorBuckets[key] = (colorBuckets[key] || 0) + 1;
                        }

                        let sortedColors = Object.entries(colorBuckets)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 10)
                            .map(([key]) => {
                                const [r, g, b] = key.split(',').map(x => parseInt(x) * 8);
                                return { r, g, b, rgb: [r, g, b] };
                            });

                        if (sortedColors.length < 3) {
                            const baseColor = sortedColors[0];
                            sortedColors = generateComplementaryColors(baseColor);
                        }

                        sortedColors = sortedColors.map(c => {
                            if (!c.h) {
                                const [h, s, l] = rgbToHsl(c.r, c.g, c.b);
                                return { ...c, h, s, l };
                            }
                            return c;
                        });

                        const palette = {
                            colors: sortedColors
                        };
                        resolve(palette);
                    };
                    img.onerror = function () {
                        console.error("Failed to load image for color extraction");
                        resolve(null);
                    };
                    img.src = imgElement.src;
                } catch (err) {
                    console.error("Error extracting palette:", err);
                    resolve(null);
                }
            });
        }

        function applyThemeColors(palette) {
            if (!palette || !palette.colors || palette.colors.length === 0) {
                console.log("No palette colors found, using defaults");
                palette = {
                    colors: [
                        { r: 255, g: 0, b: 0, h: 0, s: 100, l: 50, rgb: [255, 0, 0] },
                        { r: 0, g: 255, b: 0, h: 120, s: 100, l: 50, rgb: [0, 255, 0] },
                        { r: 0, g: 0, b: 255, h: 240, s: 100, l: 50, rgb: [0, 0, 255] }
                    ]
                };
            }

            const colors = palette.colors;

            const vibrantColors = colors
                .map(c => {
                    const [h, s, l] = rgbToHsl(c.r, c.g, c.b);
                    return { ...c, h, s, l };
                })
                .sort((a, b) => b.s - a.s)
                .slice(0, 3);

            if (vibrantColors.length === 0) {
                vibrantColors.push({
                    ...colors[0],
                    ...(rgbToHsl(colors[0].r, colors[0].g, colors[0].b) || { h: 0, s: 0, l: 50 })
                });
                if (colors[1]) {
                    vibrantColors.push({
                        ...colors[1],
                        ...(rgbToHsl(colors[1].r, colors[1].g, colors[1].b) || { h: 0, s: 0, l: 50 })
                    });
                }
            }

            const primary = vibrantColors[0];
            const secondary = vibrantColors[1] || vibrantColors[0];
            const tertiary = vibrantColors[2] || vibrantColors[0];

            const ph = primary.h;
            const ps = primary.s;
            const pl = primary.l;

            const sh = secondary.h;
            const ss = secondary.s;
            const sl = secondary.l;

            const th = tertiary.h;
            const ts = tertiary.s;
            const tl = tertiary.l;

            console.log(`Applying theme - Primary: hsl(${ph}, ${ps}%, ${pl}%)`);

            const el_info = document.querySelector(".info");
            el_info.style.backgroundImage = `
                radial-gradient(at 40% 20%, hsla(${ph},${ps}%,${Math.min(pl + 20, 90)}%,1) 0px, transparent 50%),
                radial-gradient(at 80% 0%, hsla(${sh},${ss}%,${Math.min(sl + 20, 90)}%,1) 0px, transparent 50%),
                radial-gradient(at 0% 50%, hsla(${th},${ts}%,${Math.min(tl + 20, 90)}%,1) 0px, transparent 50%),
                radial-gradient(at 80% 50%, hsla(${(ph + 180) % 360},${ps}%,${Math.min(pl + 20, 90)}%,1) 0px, transparent 50%),
                radial-gradient(at 0% 100%, hsla(${(sh + 180) % 360},${ss}%,${Math.min(sl + 20, 90)}%,1) 0px, transparent 50%),
                radial-gradient(at 80% 100%, hsla(${(th + 180) % 360},${ts}%,${Math.min(tl + 20, 90)}%,1) 0px, transparent 50%),
                radial-gradient(at 0% 0%, hsla(${ph},${ps}%,${Math.min(pl + 20, 90)}%,1) 0px, transparent 50%)
            `;

            current_palette = palette;
        }

        function slide_out() {
            let el_info = document.querySelector(".info");
            el_info.classList.remove("animation-done");
            el_info.classList.add("hide");
            void el_info.offsetWidth;
        }

        function slide_in() {
            let el_info = document.querySelector(".info");
            el_info.classList.remove("hide");
            el_info.classList.add("show");
            void el_info.offsetWidth;

            setTimeout(() => {
                el_info.classList.add("animation-done");
            }, 300);
        }

        function transition_hero(cb) {
            if (isTransitioning) return;
            isTransitioning = true;

            let el_hero_content = document.querySelector(".hero-content");
            let el_hero_name = document.querySelector(".hero-name");
            let el_hero_role = document.querySelector(".hero-role");
            let el_hero_stats_grid = document.querySelector(".hero-stats-grid");
            let el_hero_icon_container = document.querySelector(".hero-icon-container");

            const statItems = el_hero_stats_grid.querySelectorAll('.stat-item');
            statItems.forEach((item, index) => {
                item.style.animation = `stats-out-retreat 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) ${0.05 + index * 0.07}s both`;
            });
            el_hero_stats_grid.style.animation = 'stats-out-retreat 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) 0.1s both';

            el_hero_icon_container.style.animation = 'hero-icon-out 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';


            el_hero_name.style.animation = 'stats-out-retreat 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.05s both';
            el_hero_role.style.animation = 'stats-out-retreat 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.08s both';

            setTimeout(() => {
                el_hero_content.classList.add("slide-out");
                void el_hero_content.offsetWidth;

                setTimeout(async () => {
                    await cb();

                    el_hero_name.style.animation = 'none';
                    el_hero_role.style.animation = 'none';
                    el_hero_stats_grid.style.animation = 'none';
                    el_hero_icon_container.style.animation = 'none';

                    void el_hero_name.offsetWidth;
                    void el_hero_role.offsetWidth;
                    void el_hero_stats_grid.offsetWidth;
                    void el_hero_icon_container.offsetWidth;


                    el_hero_name.style.animation = '';
                    el_hero_role.style.animation = '';
                    el_hero_stats_grid.style.animation = '';



                    el_hero_icon_container.style.animation = 'hero-icon-in 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards';

                    setTimeout(() => {
                        el_hero_content.classList.remove("slide-out");
                        el_hero_content.classList.add("slide-in");
                        void el_hero_content.offsetWidth;

                        setTimeout(() => {
                            el_hero_content.classList.remove("slide-in");
                            isTransitioning = false;
                        }, 600);
                    }, 150);
                }, 300);
            }, 1000);
        }

        socket.on('connect', () => {
            console.log('Connected to server');
            socket.emit('init_client');
        });

        socket.on('rivals_info', async (data) => {
            console.log('Received rivals info:', data);
            updateProfile(data);
            heroStats = data.heroStats || [];
            if (heroStats.length > 0) {
                await startHeroRotation();
            }
            slide_in();
        });

        function updateProfile(data) {
            const platform = data.platform || {};
            const user = data.user || {};
            const metadata = data.metadata || {};
            const guild = data.metadata.clubMiniName;;

            document.getElementById('avatar').src = platform.avatarUrl || '';
            document.getElementById('username').innerText = platform.platformUserHandle || 'Unknown';

            const overview = (data.heroStats || []).find(s => s.type === 'overview');
            if (overview && overview.stats && overview.stats.ranked) {
                const rank = overview.stats.ranked;
                document.getElementById('rank').innerText = `${rank.tierName} ${rank.tierShortName} (${rank.displayValue})`;
            } else {
                document.getElementById('rank').innerText = 'Unranked';
            }

            document.getElementById('guild-name').innerText = guild || "";
        }

        async function startHeroRotation() {
            if (switchInterval) clearInterval(switchInterval);
            if (!isTransitioning) {
                await updateHeroDisplay();
            }
            switchInterval = setInterval(() => {
                if (!isTransitioning) {
                    currentHeroIndex = (currentHeroIndex + 1) % heroStats.length;
                    transition_hero(() => updateHeroDisplay());
                }
            }, 10000);
        }

        async function updateHeroDisplay() {
            if (heroStats.length === 0) return;

            const hero = heroStats[currentHeroIndex];
            let metadata = hero.metadata || {};
            const stats = hero.stats || {};
            const heroName = metadata.name || 'Unknown';

            document.getElementById('hero-name').innerText = heroName;
            document.getElementById('hero-role').innerText = metadata.roleName || '';

            const heroIcon = document.getElementById('hero-icon');
            const heroIconBg = document.getElementById('hero-icon-bg');
            const proxiedUrl = "/img_proxy?url=" + encodeURIComponent(metadata.imageUrl || "");
            heroIcon.crossOrigin = "anonymous";
            if (heroIcon.src !== proxiedUrl) {
                heroIcon.src = proxiedUrl;
                heroIconBg.style.backgroundImage = `url(${proxiedUrl})`;

                if (heroIcon.src) {
                    await new Promise((resolve) => {
                        if (heroIcon.complete && heroIcon.naturalHeight !== 0) {
                            resolve();
                        } else {
                            heroIcon.onload = () => resolve();
                            heroIcon.onerror = () => resolve();
                        }
                    });
                    const palette = await extractPaletteFromImage(heroIcon);
                    applyThemeColors(palette);
                }
            }

            const statsGrid = document.getElementById('hero-stats-grid');
            statsGrid.innerHTML = '';

            const keyStats = [
                { label: 'Kills', value: stats.kills ? stats.kills.displayValue : '0' },
                { label: 'Deaths', value: stats.deaths ? stats.deaths.displayValue : '0' },
                { label: 'Assists', value: stats.assists ? stats.assists.displayValue : '0' },
                { label: 'Wins', value: stats.matchesWon ? stats.matchesWon.displayValue : '0' },
                { label: 'Losses', value: (stats.matchesPlayed && stats.matchesWon) ? (parseFloat(stats.matchesPlayed.displayValue) - parseFloat(stats.matchesWon.displayValue)).toFixed(1) : '0' },
                { label: 'K/D', value: stats.kdRatio ? stats.kdRatio.displayValue : '0.00' },
                { label: 'Win %', value: stats.matchesWinPct ? stats.matchesWinPct.displayValue : '0%' },
                { label: 'Damage', value: stats.totalHeroDamage ? stats.totalHeroDamage.displayValue : '0' }
            ];


            const previousHeroStats = heroPreviousStats[heroName] || {};

            keyStats.forEach((stat, index) => {
                const statDiv = document.createElement('div');
                statDiv.className = 'stat-item';
                statDiv.innerHTML = `
                    <div class="stat-value">${stat.value}</div>
                    <div class="stat-label">${stat.label}</div>
                `;
                statDiv.style.animation = `float-up 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) ${0.3 + index * 0.06}s both`;
                statsGrid.appendChild(statDiv);


                if (previousHeroStats[stat.label] !== undefined && previousHeroStats[stat.label] !== stat.value) {
                    statDiv.classList.add('updated');
                    setTimeout(() => statDiv.classList.remove('updated'), 1000);
                }
            });


            heroPreviousStats[heroName] = {};
            keyStats.forEach(stat => {
                heroPreviousStats[heroName][stat.label] = stat.value;
            });
        }
    </script>
</body>

</html>